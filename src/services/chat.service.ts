import "server-only";

import { type } from "arktype";
import type { Conversation, Lead, Message } from "@/generated/prisma/client";
import prisma from "@/lib/db";
import pusherServer from "@/lib/pusher";
import {
  type StartConversation,
  StartConversationSchema,
} from "@/types/chat.schemas";
import type { Result } from "@/types/result.types";
import { handleDbError } from "@/utils/handle-db-error";
import { analyzeConversation } from "./ai.service";

/**
 * Start a new conversation with smart lead identity reconciliation
 * Handles: Lead creation/update, Conversation creation, First message, Pusher notifications
 */
export const startConversation = async (
  data: StartConversation,
): Promise<
  Result<{
    conversationId: string;
    status: string;
    confirmedLeadId: string;
  }>
> => {
  // Validate input
  const validation = StartConversationSchema(data);
  if (validation instanceof type.errors) {
    return { success: false, error: validation.summary };
  }

  try {
    let finalLeadId = data.leadId;

    // =========================================================
    // IDENTITY RECONCILIATION - Check if email already exists
    // =========================================================
    const existingLeadByEmail = await prisma.lead.findUnique({
      where: { email: data.email },
    });

    if (existingLeadByEmail) {
      // User is returning from a different device or cleared localStorage
      // Use the historic ID instead of the new one generated by the browser
      finalLeadId = existingLeadByEmail.id;

      await prisma.lead.update({
        where: { id: finalLeadId },
        data: {
          name: data.name,
          phone: data.phone,
          lastSeen: new Date(),
        },
      });
    } else {
      // New user or email not registered
      await prisma.lead.upsert({
        where: { id: finalLeadId },
        update: {
          email: data.email,
          name: data.name,
          phone: data.phone,
          lastSeen: new Date(),
        },
        create: {
          id: finalLeadId,
          email: data.email,
          name: data.name,
          phone: data.phone,
        },
      });
    }

    // =========================================================
    // CONVERSATION MANAGEMENT - Find or create active conversation
    // =========================================================
    let conversation = await prisma.conversation.findFirst({
      where: {
        leadId: finalLeadId,
        status: { in: ["QUEUED", "IN_PROGRESS"] },
      },
    });

    if (!conversation) {
      conversation = await prisma.conversation.create({
        data: {
          leadId: finalLeadId,
          status: "QUEUED",
          priority: "NORMAL",
        },
      });

      // Notify agent dashboard about new lead in queue
      await pusherServer.trigger("agents-dashboard", "new-lead", {
        conversationId: conversation.id,
        leadName: data.name,
        projectName: data.projectId,
        timestamp: new Date(),
      });
    }

    //=========================================================
    // MESSAGE CREATION - Send the first message
    // =========================================================
    const newMessage = await prisma.message.create({
      data: {
        conversationId: conversation.id,
        content: data.message,
        senderType: "LEAD",
      },
    });

    // Notify the conversation channel
    const channelName = `private-chat-${conversation.id}`;
    await pusherServer.trigger(channelName, "new-message", newMessage);

    return {
      success: true,
      value: {
        conversationId: conversation.id,
        status: conversation.status,
        confirmedLeadId: finalLeadId,
      },
    };
  } catch (error) {
    return handleDbError(error) as Result<{
      conversationId: string;
      status: string;
      confirmedLeadId: string;
    }>;
  }
};

/**
 * Get all messages for a conversation
 */
export const getConversationMessages = async (
  conversationId: string,
): Promise<Result<Message[]>> => {
  try {
    const messages = await prisma.message.findMany({
      where: { conversationId },
      orderBy: { createdAt: "asc" },
    });

    return {
      success: true,
      value: messages,
    };
  } catch (error) {
    return handleDbError(error) as Result<Message[]>;
  }
};

/**
 * Send a message in an existing conversation
 */
export const sendMessage = async (
  conversationId: string,
  content: string,
  senderType: "LEAD" | "AGENT" | "SYSTEM",
): Promise<Result<Message>> => {
  try {
    const message = await prisma.message.create({
      data: {
        conversationId,
        content,
        senderType,
      },
    });

    // Trigger Pusher notification
    const channelName = `private-chat-${conversationId}`;
    await pusherServer.trigger(channelName, "new-message", message);

    // AI Analysis (Fire-and-forget)
    // We do not await this because we don't want to block the user response
    analyzeConversation(conversationId).catch((err: unknown) => {
      console.error("Failed to trigger AI analysis:", err);
    });

    return {
      success: true,
      value: message,
    };
  } catch (error) {
    return handleDbError(error) as Result<Message>;
  }
};

/**
 * Get all queued conversations (for agent dashboard)
 */
export const getQueuedConversations = async (): Promise<
  Result<
    (Conversation & {
      lead: Lead;
    })[]
  >
> => {
  try {
    const conversations = await prisma.conversation.findMany({
      where: {
        status: "QUEUED",
      },
      include: {
        lead: true,
      },
      orderBy: { createdAt: "asc" },
    });

    return {
      success: true,
      value: conversations,
    };
  } catch (error) {
    return handleDbError(error) as Result<
      (Conversation & {
        lead: Lead;
      })[]
    >;
  }
};

/**
 * Get all conversations for a specific agent
 */
export const getAgentConversations = async (
  agentId: string,
): Promise<
  Result<
    (Conversation & {
      lead: Lead;
    })[]
  >
> => {
  try {
    const conversations = await prisma.conversation.findMany({
      where: {
        agentId,
        status: { in: ["QUEUED", "IN_PROGRESS"] },
      },
      include: {
        lead: true,
      },
      orderBy: { assignedAt: "desc" },
    });

    return {
      success: true,
      value: conversations,
    };
  } catch (error) {
    return handleDbError(error) as Result<
      (Conversation & {
        lead: Lead;
      })[]
    >;
  }
};

/**
 * Get a specific conversation by ID with all relations
 */
export const getConversationById = async (
  conversationId: string,
): Promise<
  Result<
    | (Conversation & {
        lead: Lead;
        messages: Message[];
      })
    | null
  >
> => {
  try {
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: {
        lead: true,
        messages: {
          orderBy: { createdAt: "asc" },
        },
      },
    });

    return {
      success: true,
      value: conversation,
    };
  } catch (error) {
    return handleDbError(error) as Result<
      | (Conversation & {
          lead: Lead;
          messages: Message[];
        })
      | null
    >;
  }
};
